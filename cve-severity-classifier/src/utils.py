from __future__ import annotations
from dataclasses import dataclass
from typing import Tuple, List

import pandas as pd

THRESHOLDS = (4.0, 7.0, 9.0)

def score_to_label(score: float) -> str:
    if score < 4.0:
        return "Low"
    if score < 7.0:
        return "Medium"
    if score < 9.0:
        return "High"
    return "Critical"

def is_not_borderline(score: float, border: float = 0.20, thresholds: Tuple[float, float, float] = THRESHOLDS) -> bool:
    return all(abs(score - t) > border for t in thresholds)

def build_text(df: pd.DataFrame, use_title: bool = False, use_cpes: bool = False) -> pd.Series:
    parts: List[pd.Series] = []
    if use_title and "title" in df.columns:
        parts.append(df["title"].fillna(""))
    parts.append(df["description"].fillna(""))

    if use_cpes and "cpes" in df.columns:
        def join_cpes(x):
            if isinstance(x, list):
                return " ".join(str(v) for v in x)
            return ""
        parts.append(df["cpes"].apply(join_cpes))

    text = parts[0]
    for p in parts[1:]:
        text = text + " " + p
    return text

@dataclass
class PreparedData:
    X_train: pd.Series
    y_train: pd.Series
    X_test: pd.Series
    y_test: pd.Series
    train_df: pd.DataFrame
    test_df: pd.DataFrame

def prepare_dataset(
    train_df: pd.DataFrame,
    test_df: pd.DataFrame,
    border: float = 0.20,
    min_len: int = 40,
    use_title: bool = False,
    use_cpes: bool = False,
) -> PreparedData:
    # CVSS v3.1 only for consistent labels
    train_df = train_df[train_df["cvss_v3_1"].notna()].copy()
    test_df = test_df[test_df["cvss_v3_1"].notna()].copy()

    train_df["score"] = pd.to_numeric(train_df["cvss_v3_1"], errors="coerce")
    test_df["score"] = pd.to_numeric(test_df["cvss_v3_1"], errors="coerce")

    train_df = train_df.dropna(subset=["description", "score"])
    test_df = test_df.dropna(subset=["description", "score"])

    train_df = train_df[train_df["score"] > 0].copy()
    test_df = test_df[test_df["score"] > 0].copy()

    train_df["label"] = train_df["score"].apply(score_to_label)
    test_df["label"] = test_df["score"].apply(score_to_label)

    if border and border > 0:
        train_df = train_df[train_df["score"].apply(lambda s: is_not_borderline(float(s), border=border))].copy()
        test_df = test_df[test_df["score"].apply(lambda s: is_not_borderline(float(s), border=border))].copy()

    if min_len and min_len > 0:
        train_df = train_df[train_df["description"].astype(str).str.len() >= min_len].copy()
        test_df = test_df[test_df["description"].astype(str).str.len() >= min_len].copy()

    X_train = build_text(train_df, use_title=use_title, use_cpes=use_cpes)
    y_train = train_df["label"].astype(str)
    X_test = build_text(test_df, use_title=use_title, use_cpes=use_cpes)
    y_test = test_df["label"].astype(str)

    return PreparedData(X_train, y_train, X_test, y_test, train_df, test_df)
